package com.ait.oncue.data

import android.net.Uri
import android.util.Log
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.FirebaseUser
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.Query
import com.google.firebase.storage.FirebaseStorage
import kotlinx.coroutines.tasks.await
import java.util.Date
import java.util.UUID

// ==========================================
// DATA MODELS
// ==========================================

/**
 * Represents a User in the OnCue system.
 */
data class OnCueUser(
    val uid: String = "",
    val username: String = "",
    val email: String = "",
    val profilePictureUrl: String? = null,
    val currentStreak: Int = 0,
    val lastPostDate: Date? = null // Used to calculate streak breaks
)

/**
 * Represents the Daily Prompt generated by the scheduler/AI.
 * Stored in the "prompts" collection in Firestore.
 */
data class DailyPrompt(
    val id: String = "",
    val text: String = "",
    val date: String = "", // Format: "YYYY-MM-DD" to easily find "today's" prompt
    val type: PromptType = PromptType.FUN
)

enum class PromptType {
    FUN, // "Take a photo of something purple"
    DEEP // "What are you grateful for?"
}

/**
 * Represents a user's submission to a prompt.
 */
data class Post(
    val id: String = "",
    val userId: String = "",
    val username: String = "", // Storing username here reduces the need for extra lookups
    val promptId: String = "",
    val textContent: String? = null,
    val imageUrl: String? = null,
    val timestamp: Date = Date()
)

// ==========================================
// REPOSITORY (The Backend Logic)
// ==========================================

class OnCueRepository {

    private val auth: FirebaseAuth = FirebaseAuth.getInstance()
    private val db: FirebaseFirestore = FirebaseFirestore.getInstance()
    private val storage: FirebaseStorage = FirebaseStorage.getInstance()

    // ------------------------------------------
    // AUTHENTICATION
    // ------------------------------------------

    fun getCurrentUser(): FirebaseUser? = auth.currentUser

    /**
     * Signs up a new user and creates their profile in Firestore.
     */
    suspend fun signUp(email: String, pass: String, username: String): Result<Boolean> {
        return try {
            val authResult = auth.createUserWithEmailAndPassword(email, pass).await()
            val uid = authResult.user?.uid ?: throw Exception("User creation failed")

            // Create the User document in Firestore
            val newUser = OnCueUser(uid = uid, username = username, email = email)
            db.collection("users").document(uid).set(newUser).await()

            Result.success(true)
        } catch (e: Exception) {
            Log.e("OnCueAuth", "Error signing up", e)
            Result.failure(e)
        }
    }

    suspend fun signIn(email: String, pass: String): Result<Boolean> {
        return try {
            auth.signInWithEmailAndPassword(email, pass).await()
            Result.success(true)
        } catch (e: Exception) {
            Log.e("OnCueAuth", "Error signing in", e)
            Result.failure(e)
        }
    }

    // ------------------------------------------
    // CORE FEATURES: PROMPTS & SUBMISSION
    // ------------------------------------------

    /**
     * Fetches the prompt for a specific date (YYYY-MM-DD).
     * Used by the Feed UI to show the "Challenge of the day".
     */
    suspend fun getDailyPrompt(dateString: String): Result<DailyPrompt?> {
        return try {
            val snapshot = db.collection("prompts")
                .whereEqualTo("date", dateString)
                .limit(1)
                .get()
                .await()

            val prompt = snapshot.documents.firstOrNull()?.toObject(DailyPrompt::class.java)
            Result.success(prompt)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    /**
     * Submits a post. This handles:
     * 1. Image upload to Firebase Storage (if an image exists)
     * 2. Saving the Post object to Firestore
     * 3. Updating the User's Streak
     */
    suspend fun submitPost(
        promptId: String,
        text: String?,
        imageUri: Uri?
    ): Result<Boolean> {
        val user = auth.currentUser ?: return Result.failure(Exception("Not logged in"))

        return try {
            var downloadUrl: String? = null

            // 1. Upload Image if it exists
            if (imageUri != null) {
                // Path: posts/{userId}/{randomID}.jpg
                val ref = storage.reference.child("posts/${user.uid}/${UUID.randomUUID()}.jpg")
                ref.putFile(imageUri).await()
                downloadUrl = ref.downloadUrl.await().toString()
            }

            // 2. Create Post Object
            // Fetch current username to attach to the post
            val userDoc = db.collection("users").document(user.uid).get().await()
            val currentUsername = userDoc.getString("username") ?: "Anonymous"

            val newPost = Post(
                id = UUID.randomUUID().toString(),
                userId = user.uid,
                username = currentUsername,
                promptId = promptId,
                textContent = text,
                imageUrl = downloadUrl,
                timestamp = Date()
            )

            // 3. Save to Firestore
            db.collection("posts").document(newPost.id).set(newPost).await()

            // 4. Update Streak Logic
            updateUserStreak(user.uid)

            Result.success(true)
        } catch (e: Exception) {
            Log.e("OnCuePost", "Error submitting post", e)
            Result.failure(e)
        }
    }

    // ------------------------------------------
    // THE "REVEAL" MECHANIC
    // ------------------------------------------

    /**
     * This is the logic for "Friends can only view your post after they submit theirs".
     * Returns a Sealed Class state:
     * - Locked: User hasn't posted yet (show blur/lock screen)
     * - Unlocked: User has posted (show list of friend posts)
     */
    sealed class FeedState {
        object Locked : FeedState()
        data class Unlocked(val posts: List<Post>) : FeedState()
        data class Error(val message: String) : FeedState()
    }

    suspend fun getFeedForPrompt(promptId: String): FeedState {
        val user = auth.currentUser ?: return FeedState.Error("No user logged in")

        return try {
            // Step 1: Check if CURRENT USER has submitted for this prompt
            val mySubmissionSnapshot = db.collection("posts")
                .whereEqualTo("userId", user.uid)
                .whereEqualTo("promptId", promptId)
                .limit(1)
                .get()
                .await()

            if (mySubmissionSnapshot.isEmpty) {
                // User hasn't posted yet. The feed is LOCKED.
                return FeedState.Locked
            }

            // Step 2: If we are here, the user has posted. Fetch all friends' posts.
            val allPostsSnapshot = db.collection("posts")
                .whereEqualTo("promptId", promptId)
                .orderBy("timestamp", Query.Direction.DESCENDING)
                .get()
                .await()

            val posts = allPostsSnapshot.documents.mapNotNull { it.toObject(Post::class.java) }
            FeedState.Unlocked(posts)

        } catch (e: Exception) {
            FeedState.Error(e.message ?: "Unknown error")
        }
    }

    // ------------------------------------------
    // HELPER LOGIC
    // ------------------------------------------

    private suspend fun updateUserStreak(userId: String) {
        val userRef = db.collection("users").document(userId)

        db.runTransaction { transaction ->
            val snapshot = transaction.get(userRef)
            // Logic to check dates and increment 'currentStreak' would go here
            // For MVP, we just update the lastPostDate
            transaction.update(userRef, "lastPostDate", Date())
        }.await()
    }
}